<!-- es un archivo markdown donde vamos poder especificar nuestro proyecto  -->

# API REST trabajo en clase

- En el dia de la fecha 18 de diciembre de 2023. Modularizamos el proyecto con las carpertas necesarias para poder tener un mejor orden, instalamos dependecias necesarias y inicializamos el servidor.

- En el dia de la fecha 19 de diciembre de 2023. Hicimos la conexion a la DB de mongodb con mongoose donde le pasamo nuestra URL desde una varible de entorno para mas seguridad ya que tiene info delicada, tambien creamos un modelo de schema para los usuarios con sus propiedades correspondientes, creamos las rutas de autenticacion con sus controladores y utilizamos el verbo "post" para recibir petisiones de usuario, usamos la aplicacion "Posman" para testiar los requerimientos del user y que funcionen bien las rutas, leimos las consultas del usuario que pasan y se guardan en "req.body".

-En el dia de la fecha 21 de diciembre de 2023. Hicimos las validaciones del lado del backend con express-validation, creamos un middleware para obtener los resultados del las validaciones express y interceptarlas antes de llegar al metodo que ejecuta los controladores de las rutas, tambien hasheamos las contraseñas registradas por el user, donde usamos el metodo "pre" del Schema para interceptar el guardado y hashear la contraseña antes de guardarla. Creamos el repositorio con un primer commit en github para guardar nuestro proyecto.

-En el dia de la fecha 25 de diciembre de 2023. Guardamos al usuario en la base de datos y consultamos a la misma con el metodo findOne del modelo para poder hacer una validacion del lado del backend donde preguntamos si el email del usuario ya existe en nuestra DB.

-En el dia de la fecha 27 de diciembre de 2023. Hicimos las consultas preguntando a la DB si el usuario esta registrado para poder iniciar secion, este metodo lo generamos en auth controller del controlador del login, en el mismo generamos un token con los metodos de JSONWEBTOKEN y proximas clases seguir desarrollando el token de seguridad. 

-En el dia de la fecha 28 de diciembre de 2023. Seguimos desarrollando el token de seguridad, vimos las opciones mas comunes y comodas pero pocos seguras del guardado del token que son localstorage, cookie, pero ningunas de ellas vamos a usar, vamos hacer otro metodo que lo vamos a implementar en proximas clases. Tambien pasamos el como generar el token a un metodo en un archivo util, despues cremos un middleware para interseptar las rutas para verificar si el token existe o este funcionando correctamente, segun su estado va a seguir o no con los metodos de esa ruta. Tambien le pasamos una propiedad "uid" al request donde le asignamos el uid del token que viene del payload que fue donde le pasamos ese dato no delicado del user para firmar el token, todo esto lo hicimos en el middleware validationToken, por lo tanto, toda ruta que tenga este middleware va a tener acceso a ese req.uid.

-En el dia de la fecha 29 de diciembre de 2023. Hicimos un metodo para capturar en un switch los posibles errores que provengan del token en un archivo util y lo llamamos en la verificacion o validacion del token. Hicimos la persistencia del token que se trata de como almacenar el token en el navegador para que persista en la sesion del usuario, ya que, si recargamos la pagina o expira el token se pierde y se estara perdiendo la sesion tambien por lo tanto el usuario tendria que iniciarla cada vez que se recargue y no es lo correcto. En el dia de hoy hicimos la primera parte de pesistencia del token y lo hicimos con un ejemplo donde creamos un directorio public donde va a estar un archivo index.html donde simulamos lo que hace postman desde el codigo mediante fetch en modo de ejemplo para entender como es el tema de persistencia token, ya que el public seria un directorio del frontend donde es expuesta y este momento solo estamos trabajando del lado del backend haciendo nuestra api rest.

-En el dia de la fecha 3 de enero de 2024. Continuamos con lo que es persistencia del token, donde creamos otro archivo "protected.html" que va hacer una ruta protegida que va hacer accedida segun si el token existe y esta correcto, tambien mediante DOM le pintamos a un elemento h2 los datos del user que es el "email", que a su vez lo obtuvimos desde el metodo fetch en un archivo "pretected.js" donde cosultamos los datos que se obtinen desde la ruta /api/v1/auth/protected desde un metodo GET.

-En el dia de la fecha 4 de enero de 2024. hicimos el guardado del token(Persistencia del token) en dos metodos diferente pero pocos seguros que son: localStorage que es el mas inseguro y cookie que es mas seguro que localStorage pero ninguno de estos va hacer el definitivo. Estos fueron solo de practica.

-En el dia de la fecha 5 de enero de 2024. Hicimos el metodo RefreshToken que es el metodo definitivo para guardar el token y que persista, este metodo consiste en tener dos token uno que nos permita refrescar y otro que nos permita hacer las peticiones a las rutas que hacen las consultas la DB. Lo primero que hicimos fue crear un segundo metodo en tokenManager.js que es para generar el refreshToken y guardarlo en una cookie, despues hicimos un middleware para validar ese refreshToken mediante el token que guardamos en ese cookie, tambien creamos un controlador para una vez que el refresh token sea valido poder crear uno nuevo y refrescarlo, todo esto lo ejecutamos desde una ruta llamada "/refresh", despues creamos un metodo fetch en el archivo protected.js donde consumimos la ruta "/refresh" donde le pasamos las credenciales para poder acceder al nombre de la cookie y creamos otro fetch para consultar los datos del usuario ya que tendriamos acceso gracias al refreshToken que nos proporsiona el token original y seguro para poder hacer esas petisiones.

-En el dia de la fecha 8 de enero de 2024. Hicimos el cierre de session para destruir el contenido de la cookie caundo el usuario cierra su session.

-En el dia de la fecha 9 de enero de 2024. Hicimos una refatorizacion de codigo, tambien hicimos un middleware para las validaciones de las rutas de autenticacion llamado "validatorManger".

-En el dia de la fecha 10 de enero de 2024. Creamos el modelo LINK con su Schema, tambien creamos las rutas de ese modelo para hacer los metodos CRUD, donde para ello tambien hicimos el controlador, que como primer metodo hicimos el READ que es un metodo GET de solo lectura donde trajimos los link por uid de usuario.

-En el dia de la fecha 11 de enero de 2024. Hicimos el metodo createLink para crear las url por usuario en el controlador de link, tambien agreagamos mas validaciones de express en el middleware validatorManager para el token y el refres token. y por ultimo en el controlador del auth en el metodo register agregamos los metodos de generar token y refresh token. Proxima clase seguimos puliendo el metodo CREATE donde vamos a validar la url con axios.

-En el dia de la fecha 12 de enero de 2024. Hicimos la validacion de las url, donde creamos un metodo "linkValidator" en el middleware "validatorManager" que consiste en validar que la url sea correcta, que no este vacia y que solo sea en un formato seguro como "https://" usamos el paquete express-validator para las validaciones y el paquete Axios para la lectura de la url con el verbo "GET" Y evaluar que sea una url ya que axios se encarga de hacer solicitudes.

-En el dia de la fecha 15 de enero de 2024. Hicimos un metodo CRUD para buscar un link especifico mediante la propiedad nanolink del Modelo Link este metodo es de lectura(READ), tambien hicimos otro metodo CRUD para remover un link en especifico utilizando la misma estructura del metodo anterior ya que utilizamos el nanolink para eliminar ese link en especifico, este metodo CRUD es de eliminacion (DELETE).

-En el dia de la fecha 17 de enero de 2024. Hicimos el ultimo metodo CRUD que es el UPDATE, tambien le agregamos validaciones a los params que recibimos en la URL para asegurar que el nanolink que pasamos por param sea valido. 

-En el dia de la fecha 17 de enero de 2024. Modificamos el metodo CRUD getLink que es para la busqueda del link para que sea publico y que cualquiera pueda acceder a la busqueda, tambien hicimos de modo de ejemplo el redireccionamiento del lado del back 

-En el dia de la fecha 22 de enero de 2024. Vimos lo que es mongoose sanitize y que si en el modelo especificamos que la pripiedad type sea de tipo string no deveria aceptar una consulta en tipo objeto "{ $en: 1}" ya que de este modo pueden enviar consultas malisiosas en las petisiones https. Si la propiedad seria de tipo Objet se deberia aplicar el metodo sanitize de express mongoose sanitize si estamos trabajando con DB noSQL como MongoDB. 

-En el dia de la fecha 23 de enero de 2024. Hicimos las seguridad del acceso a nuestro backend desde un servidor con el middleware CORS que nos permite la comunicacion entre servidores que solo nosotros le demos acceso para que nuestro back no sea accedido por cualquira.